# Когда запускается система синхронизации

## Текущее поведение

### Ручной запуск (сейчас)

Система запускается **только вручную** через UI:

1. Откройте страницу настроек (Settings/Sync)
2. Нажмите кнопку:
   - **"Синхронизировать всё"** - полная синхронизация всех периодов
   - **"Синхронизировать за период"** - синхронизация за выбранный диапазон дат

### Что происходит при запуске

1. **Инициализация сервисов** (`initializeServices()`):
   - Создается `ReportSyncServiceV2`
   - Создается `SyncCoordinator`
   - Создается `DataPersistenceService`
   - Создается `SyncRegistryRepository`

2. **Проверка запланированных повторов** (`initializeRetryScheduler()`):
   - Проверяются записи со статусом `waiting`, у которых `nextRetryAt <= now`
   - Эти периоды будут обработаны в первую очередь

3. **Запуск синхронизации** (`startSync()`):
   - Система получает следующую задачу по приоритету
   - Выполняет синхронизацию
   - Повторяет до тех пор, пока есть задачи

## Приоритеты синхронизации

При запуске система обрабатывает задачи в следующем порядке:

1. **Pending/Waiting периоды** из реестра (готовые к повтору)
2. **Прошлая неделя** (weekly, если не финальная)
3. **Текущая неделя** (daily)

## Автозапуск при загрузке страницы (опционально)

Если вы хотите, чтобы система автоматически проверяла и синхронизировала данные при загрузке страницы, можно добавить следующий код:

### Вариант 1: Автозапуск при монтировании компонента

В `ReportSyncPanel.vue` или в `App.vue`:

```typescript
import { onMounted } from 'vue'
import { useWbStore } from '@presentation/stores/wbStore'

onMounted(async () => {
  const store = useWbStore()
  
  // Проверяем, есть ли запланированные повторы
  // Можно использовать SyncDebug для проверки
  if (typeof window !== 'undefined' && (window as any).SyncDebug) {
    const readyForRetry = await db.syncRegistry
      .where('status')
      .equals('waiting')
      .toArray()
    
    const now = Date.now()
    const shouldSync = readyForRetry.some(e => e.nextRetryAt && e.nextRetryAt <= now)
    
    if (shouldSync) {
      // Автоматически запускаем синхронизацию
      await store.startSync()
    }
  }
})
```

### Вариант 2: Фоновый воркер (Service Worker)

Для более продвинутого варианта с автоматической проверкой даже когда вкладка закрыта, можно использовать Service Worker, но это сложнее в реализации.

## Рекомендации

### Для большинства случаев

**Оставить как есть** (ручной запуск):
- ✅ Пользователь контролирует, когда запускать синхронизацию
- ✅ Не тратятся ресурсы без необходимости
- ✅ Можно запустить синхронизацию за конкретный период

### Если нужен автозапуск

**Вариант 1** (простой):
- Добавить проверку при монтировании главной страницы
- Если есть готовые к повтору периоды → запустить синхронизацию

**Вариант 2** (продвинутый):
- Использовать Service Worker для фоновой синхронизации
- Периодически проверять реестр и запускать синхронизацию

## Проверка готовности к синхронизации

Вы можете проверить, есть ли периоды, готовые к синхронизации:

```javascript
// В консоли браузера
SyncDebug.checkSyncRegistry()
```

Или программно:

```typescript
import { db } from '@infrastructure/db/database'

const readyForRetry = await db.syncRegistry
  .where('status')
  .equals('waiting')
  .toArray()

const now = Date.now()
const shouldSync = readyForRetry.some(
  e => e.nextRetryAt && e.nextRetryAt <= now
)
```

## Что происходит с waiting записями

Записи со статусом `waiting` (пустой ответ от API) **не обрабатываются автоматически** до следующего ручного запуска синхронизации. При следующем запуске они будут обработаны в первую очередь (если `nextRetryAt <= now`).

Если нужно автоматически обрабатывать waiting записи, добавьте автозапуск как описано выше.
